import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../../domain/entities/assistant/assistant_response.dart';
import '../../../domain/entities/chat/chat_message.dart';
import 'deep_learning_datasource.dart';
import '../../../domain/entities/deep_learning_analysis.dart';
import '../../models/assistant/assistant_response_model.dart';
import '../../services/habit_auto_creation_service.dart';
import '../../services/gemini_response_processor_service.dart';

class GeminiAssistantDatasource {
  final String _apiKey;
  final String _baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  final http.Client _httpClient;
  final DeepLearningDatasource? _deepLearningDatasource;
  final HabitAutoCreationService _habitAutoCreationService;
  final GeminiResponseProcessorService? _responseProcessor;
  
  // Mapeo interno para mantener relaci√≥n nombre -> datos completos
  Map<String, Map<String, dynamic>> _habitNameToDataMap = {};
  Map<String, Map<String, dynamic>> _similarHabitsMap = {};

  GeminiAssistantDatasource({
    String? apiKey,
    http.Client? httpClient,
    DeepLearningDatasource? deepLearningDatasource,
    required HabitAutoCreationService habitAutoCreationService,
    GeminiResponseProcessorService? responseProcessor,
  }) : _apiKey = apiKey ?? 'AIzaSyBVYo2LtacVZLUg88-lyqqi9zHGc6O2BDw',
       _httpClient = httpClient ?? http.Client(),
       _deepLearningDatasource = deepLearningDatasource,
       _habitAutoCreationService = habitAutoCreationService,
       _responseProcessor = responseProcessor;

  /// Nuevo m√©todo para respuestas progresivas con an√°lisis m√©dico integrado
  Future<AssistantResponseModel> sendMessageWithProgressiveResponse({
    required String message,
    required String userId,
    required List<ChatMessage> conversationHistory,
    String? sessionId,
    required Function(String) onProgressUpdate,
  }) async {
    try {
      print('üöÄ [PROGRESSIVE] Iniciando respuesta progresiva...');
      
      // FASE 1: Respuesta r√°pida inicial de Gemini
      onProgressUpdate('Analizando tu mensaje...');
      
      String initialGeminiResponse;
      bool geminiAvailable = true;
      
      try {
        // Obtener respuesta inicial r√°pida de Gemini
        initialGeminiResponse = await _getInitialGeminiResponse(message, userId, conversationHistory);
        print('‚úÖ [PROGRESSIVE] Respuesta inicial de Gemini obtenida');
        onProgressUpdate('Generando respuesta inicial...');
      } catch (e) {
        print('‚ùå [PROGRESSIVE] Error en respuesta inicial de Gemini: $e');
        geminiAvailable = false;
        initialGeminiResponse = _createGeminiFallbackResponse(message, userId, e.toString());
      }
      
      // FASE 2: Procesar respuesta inicial y extraer s√≠ntomas
      onProgressUpdate('Procesando informaci√≥n m√©dica...');
      
      Map<String, dynamic> extractedSymptoms = _extractSymptomsFromMessage(message);
      print('üîç [PROGRESSIVE] S√≠ntomas extra√≠dos: $extractedSymptoms');
      
      // FASE 3: Llamar al nuevo endpoint de an√°lisis m√©dico en paralelo
      Future<MedicalAnalysisResponse?> medicalAnalysisFuture = _getMedicalAnalysis(
        userId: userId,
        userMessage: message,
        extractedSymptoms: extractedSymptoms,
        onProgress: onProgressUpdate,
      );
      
      // FASE 4: Procesar respuesta estructurada inicial
      String initialMessage = initialGeminiResponse;
      Map<String, dynamic> processedActions = {};
      List<Map<String, dynamic>> suggestedHabits = [];
      
      if (_responseProcessor != null) {
        try {
          onProgressUpdate('Estructurando recomendaciones...');
          final processedResponse = await _responseProcessor!.processGeminiResponse(
            initialGeminiResponse,
            userId,
          );
          
          processedResponse.fold(
            (failure) {
              print('‚ùå [PROGRESSIVE] Error procesando respuesta estructurada: $failure');
              initialMessage = _formatGeminiResponse(initialGeminiResponse);
            },
            (processed) {
              print('‚úÖ [PROGRESSIVE] Respuesta estructurada procesada');
              initialMessage = processed.message;
              processedActions = processed.actions;
              
              if (processedActions.containsKey('new_habits')) {
                suggestedHabits = List<Map<String, dynamic>>.from(
                  processedActions['new_habits'] as List<dynamic>
                );
              }
            },
          );
        } catch (e) {
          print('‚ùå [PROGRESSIVE] Error en procesamiento estructurado: $e');
          initialMessage = _formatGeminiResponse(initialGeminiResponse);
        }
      } else {
        initialMessage = _formatGeminiResponse(initialGeminiResponse);
      }
      
      // FASE 5: Crear respuesta inicial para mostrar al usuario
      final initialResponse = AssistantResponseModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        sessionId: sessionId ?? '',
        content: initialMessage,
        type: ResponseType.text,
        timestamp: DateTime.now(),
        confidence: 0.7, // Confianza inicial
        suggestions: [],
        extractedHabits: _extractHabitsFromResponse(initialMessage),
        analysisData: null,
        suggestedHabits: suggestedHabits,
        dlChatResponse: null,
        processedActions: processedActions,
      );
      
      // FASE 6: Esperar an√°lisis m√©dico y combinar respuestas
      onProgressUpdate('Obteniendo an√°lisis m√©dico especializado...');
      
      try {
        final medicalAnalysis = await medicalAnalysisFuture;
        
        if (medicalAnalysis != null) {
          print('‚úÖ [PROGRESSIVE] An√°lisis m√©dico obtenido exitosamente');
          onProgressUpdate('Integrando an√°lisis m√©dico...');
          
          // Combinar respuesta inicial con an√°lisis m√©dico
          final enhancedResponse = await _combineGeminiWithMedicalAnalysis(
            initialResponse: initialResponse,
            medicalAnalysis: medicalAnalysis,
            originalMessage: message,
            userId: userId,
            onProgress: onProgressUpdate,
          );
          
          print('‚úÖ [PROGRESSIVE] Respuesta final combinada exitosamente');
          return enhancedResponse;
        } else {
          print('‚ö†Ô∏è [PROGRESSIVE] No se pudo obtener an√°lisis m√©dico, usando respuesta inicial');
          onProgressUpdate('Finalizando respuesta...');
          return initialResponse;
        }
      } catch (e) {
        print('‚ùå [PROGRESSIVE] Error en an√°lisis m√©dico: $e');
        onProgressUpdate('Finalizando respuesta...');
        return initialResponse;
      }
      
    } catch (e) {
      print('üí• [PROGRESSIVE] Error general en respuesta progresiva: $e');
      throw Exception('Error al generar respuesta progresiva: $e');
    }
  }

  Future<AssistantResponseModel> sendMessage({
    required String message,
    required String userId,
    required List<ChatMessage> conversationHistory,
    String? sessionId,
  }) async {
    try {
      // Intentar obtener respuesta de Gemini con fallback
      String geminiResponse;
      bool geminiAvailable = true;
      
      try {
        geminiResponse = await _getGeminiResponse(message, userId, conversationHistory);
        print('‚úÖ Respuesta de Gemini obtenida exitosamente');
      } catch (e) {
        print('‚ùå Error en API de Gemini: $e');
        geminiAvailable = false;
        geminiResponse = _createGeminiFallbackResponse(message, userId, e.toString());
      }
      
      // CAMBIO: Devolver SOLO la respuesta de Gemini primero
      // El Deep Learning se procesar√° en segundo plano desde assistant_bloc.dart
      print('üî• DEBUG: Devolviendo respuesta de Gemini sin Deep Learning para procesamiento inmediato');
      
      // Procesar respuesta estructurada de Gemini si est√° disponible el procesador
      String finalMessage = geminiResponse;
      Map<String, dynamic> processedActions = {};
      List<Map<String, dynamic>> suggestedHabits = [];
      
      if (_responseProcessor != null) {
        try {
          print('üî• DEBUG: Procesando respuesta estructurada de Gemini');
          final processedResponse = await _responseProcessor!.processGeminiResponse(
            geminiResponse,
            userId,
          );
          
          processedResponse.fold(
            (failure) {
              print('‚ùå Error procesando respuesta estructurada: $failure');
              // Usar respuesta original como fallback
              finalMessage = _formatGeminiResponse(geminiResponse);
            },
            (processed) {
              print('‚úÖ Respuesta estructurada procesada exitosamente');
              finalMessage = processed.message;
              processedActions = processed.actions;
              
              // Extraer h√°bitos sugeridos de las acciones procesadas
              if (processedActions.containsKey('new_habits')) {
                suggestedHabits = List<Map<String, dynamic>>.from(
                  processedActions['new_habits'] as List<dynamic>
                );
              }
            },
          );
        } catch (e) {
          print('‚ùå Error en procesamiento estructurado: $e');
          finalMessage = _formatGeminiResponse(geminiResponse);
        }
      } else {
        // Fallback al procesamiento tradicional
        finalMessage = _formatGeminiResponse(geminiResponse);
        
        // Crear objeto AssistantResponse temporal para creaci√≥n de h√°bitos
        final tempResponse = AssistantResponseModel(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          sessionId: sessionId ?? '',
          content: finalMessage,
          type: ResponseType.text,
          timestamp: DateTime.now(),
        );
        
        // Extraer h√°bitos sugeridos para mostrar en desplegable (sin crear autom√°ticamente)
        try {
          print('üî• DEBUG GEMINI: Iniciando extracci√≥n de h√°bitos sugeridos (m√©todo tradicional)');
          
          final extractedHabits = await _habitAutoCreationService.extractSuggestedHabits(
            assistantResponse: tempResponse,
            userMessage: message,
            userId: userId,
          );
          suggestedHabits = extractedHabits.map((habit) => habit.toMap()).toList();
          
          print('üî• DEBUG GEMINI: Se extrajeron ${suggestedHabits.length} h√°bitos sugeridos para desplegable');
        } catch (e) {
          print('üî• ERROR GEMINI: Error extracting suggested habits: $e');
        }
      }
      
      return AssistantResponseModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        sessionId: sessionId ?? '',
        content: finalMessage,
        type: ResponseType.text,
        timestamp: DateTime.now(),
        confidence: 0.8, // Confianza base de Gemini
        suggestions: [], // Se llenar√°n con Deep Learning en segundo plano
        extractedHabits: _extractHabitsFromResponse(finalMessage),
        analysisData: null, // Se llenar√° con Deep Learning en segundo plano
        suggestedHabits: suggestedHabits,
        dlChatResponse: null, // Se llenar√° con Deep Learning en segundo plano
        processedActions: processedActions, // Acciones procesadas de Gemini
      );
    } catch (e) {
      throw Exception('Error al enviar mensaje: $e');
    }
  }

  Future<AssistantResponseModel> processVoiceMessage({
    required String audioPath,
    required String sessionId,
    required String userId,
    List<ChatMessage>? conversationHistory,
  }) async {
    try {
      // Primero convertir audio a texto (esto requerir√≠a integraci√≥n con Speech-to-Text)
      final transcribedText = await _speechToText(audioPath);
      
      // Luego procesar el texto con Gemini
      return await sendMessage(
          message: transcribedText,
          userId: userId,
          conversationHistory: conversationHistory ?? [],
        );
    } catch (e) {
      throw Exception('Error al procesar mensaje de voz: $e');
    }
  }

  /// Procesa Deep Learning por separado y devuelve el an√°lisis
  Future<Map<String, dynamic>> processDeepLearningAnalysis({
    required String message,
    required String userId,
    String? sessionId,
  }) async {
    try {
      print('üî• DEBUG: ===== INICIANDO PROCESAMIENTO DE DEEP LEARNING =====');
      
      // Obtener respuesta del backend de deep learning con manejo robusto de errores
      Map<String, dynamic>? dlChatResponse;
      DeepLearningAnalysis? deepLearningAnalysis;
      bool dlServiceAvailable = false;
      
      if (_deepLearningDatasource != null) {
        // Verificar salud del servicio primero
        try {
          dlServiceAvailable = await _deepLearningDatasource!.checkModelHealth();
          print('üîç Estado del servicio Deep Learning: ${dlServiceAvailable ? "Disponible" : "No disponible"}');
        } catch (e) {
          print('‚ö†Ô∏è Error verificando salud del servicio DL: $e');
          dlServiceAvailable = false;
        }
        
        // Intentar obtener respuesta de chat si el servicio est√° disponible
        if (dlServiceAvailable) {
          try {
            dlChatResponse = await _getDeepLearningChatResponse(message, userId, sessionId);
            print('‚úÖ Respuesta de chat DL obtenida exitosamente');
          } catch (e) {
            print('‚ùå Error en chat de deep learning: $e');
            // Crear respuesta de fallback con contexto del error
            dlChatResponse = _createEnhancedFallbackResponse(message, userId, e.toString());
          }
        } else {
          // Crear respuesta de fallback cuando el servicio no est√° disponible
          dlChatResponse = _createEnhancedFallbackResponse(message, userId, 'Servicio no disponible');
        }
        
        // Intentar obtener an√°lisis de deep learning
        try {
          if (dlServiceAvailable) {
            deepLearningAnalysis = await _getDeepLearningAnalysis(message, userId);
            print('‚úÖ An√°lisis DL obtenido exitosamente');
          }
        } catch (e) {
          print('‚ùå Error en an√°lisis de deep learning: $e');
          // Continuar sin an√°lisis pero registrar el error para m√©tricas
          _logDeepLearningError('analysis', e.toString());
        }
      } else {
        print('‚ö†Ô∏è Deep Learning datasource no configurado');
        // Crear respuesta b√°sica cuando no hay datasource configurado
        dlChatResponse = _createEnhancedFallbackResponse(message, userId, 'Servicio no configurado');
      }
      
      print('üî• DEBUG: ===== DEEP LEARNING PROCESAMIENTO COMPLETADO =====');
      
      return {
        'dlChatResponse': dlChatResponse,
        'deepLearningAnalysis': deepLearningAnalysis,
        'serviceAvailable': dlServiceAvailable,
      };
    } catch (e) {
      print('‚ùå Error en procesamiento de Deep Learning: $e');
      return {
        'dlChatResponse': null,
        'deepLearningAnalysis': null,
        'serviceAvailable': false,
        'error': e.toString(),
      };
    }
  }

  Future<List<String>> getContextualSuggestions({
    required String userId,
    required String currentContext,
  }) async {
    try {
      final prompt = '''
Contexto: "$currentContext"

3 sugerencias para gastritis (m√°ximo 4 palabras cada una):
Formato: sugerencia1, sugerencia2, sugerencia3''';

      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/models/gemini-2.5-flash:generateContent?key=$_apiKey'),
        headers: {
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'contents': [
            {
              'parts': [
                {'text': prompt}
              ]
            }
          ],
          'generationConfig': {
            'temperature': 0.8,
            'maxOutputTokens': 100,
          },
        }),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final content = data['candidates']?[0]?['content']?['parts']?[0]?['text'] ?? '';
        
        return content
            .split(',')
            .map((s) => s.trim())
            .where((s) => s.isNotEmpty)
            .take(3)
            .toList();
      } else {
        return ['Beber m√°s agua', 'Comer despacio', 'Reducir estr√©s'];
      }
    } catch (e) {
      // Sugerencias por defecto en caso de error
      return ['Beber m√°s agua', 'Comer despacio', 'Reducir estr√©s'];
    }
  }

  /// Obtiene los nombres de h√°bitos existentes del usuario para evitar duplicados
  /// Mantiene un mapeo interno de nombres a datos completos para interpretaci√≥n posterior
  Future<List<String>> _getUserExistingHabits(String? userId) async {
    if (userId == null) return [];
    
    try {
      final response = await Supabase.instance.client
          .from('user_habits')
          .select('''
            id,
            habit_id,
            custom_name,
            is_active,
            habits!inner(
              id,
              name,
              category_id
            )
          ''')
          .eq('user_id', userId)
          .eq('is_active', true);

      final habitData = List<Map<String, dynamic>>.from(response);
      final habitNames = <String>[];
      
      // Limpiar mapeo anterior
      _habitNameToDataMap.clear();
      
      // Extraer nombres y crear mapeo interno
      for (final habit in habitData) {
        final habitName = habit['custom_name'] ?? habit['habits']?['name'] ?? 'H√°bito personalizado';
        habitNames.add(habitName);
        
        // Guardar datos completos en el mapeo interno
        _habitNameToDataMap[habitName] = habit;
      }
      
      return habitNames;
    } catch (e) {
      print('Error obteniendo h√°bitos existentes: $e');
      return [];
    }
  }

  /// Busca nombres de h√°bitos similares en la tabla habits usando LIKE
  /// Mantiene un mapeo interno de nombres a datos completos para interpretaci√≥n posterior
  Future<List<String>> _findSimilarHabits(String habitName) async {
    try {
      final response = await Supabase.instance.client
          .from('habits')
          .select('id, name, description, category_id, icon_name, icon_color')
          .ilike('name', '%$habitName%')
          .eq('is_active', true)
          .limit(5);

      final habitData = List<Map<String, dynamic>>.from(response);
      final habitNames = <String>[];
      
      // Extraer nombres y actualizar mapeo interno
      for (final habit in habitData) {
        final name = habit['name'] as String;
        habitNames.add(name);
        
        // Guardar datos completos en el mapeo interno
        _similarHabitsMap[name] = habit;
      }
      
      return habitNames;
    } catch (e) {
      print('Error buscando h√°bitos similares: $e');
      return [];
    }
  }

  /// Obtiene los datos completos de un h√°bito del usuario por su nombre
  Map<String, dynamic>? getUserHabitDataByName(String habitName) {
    return _habitNameToDataMap[habitName];
  }

  /// Obtiene los datos completos de un h√°bito similar por su nombre
  Map<String, dynamic>? getSimilarHabitDataByName(String habitName) {
    return _similarHabitsMap[habitName];
  }

  /// Limpia los mapeos internos (√∫til para testing o reset)
  void clearInternalMappings() {
    _habitNameToDataMap.clear();
    _similarHabitsMap.clear();
  }

  /// Obtiene h√°bitos similares disponibles basados en palabras clave del mensaje
  Future<List<String>> _getSimilarHabitsForMessage(String message) async {
    final lowerMessage = message.toLowerCase();
    final allSimilarHabits = <String>[];
    
    // Palabras clave para buscar h√°bitos relacionados
    final keywords = <String>[];
    
    // Detectar categor√≠as de h√°bitos basadas en el mensaje
    if (_containsAnyKeyword(lowerMessage, ['agua', 'hidrat', 'beber', 'l√≠quido'])) {
      keywords.add('agua');
      keywords.add('hidrataci√≥n');
    }
    
    if (_containsAnyKeyword(lowerMessage, ['ejercicio', 'actividad', 'caminar', 'deporte', 'f√≠sico'])) {
      keywords.add('ejercicio');
      keywords.add('actividad');
      keywords.add('caminar');
    }
    
    if (_containsAnyKeyword(lowerMessage, ['comida', 'alimentaci√≥n', 'comer', 'dieta', 'nutrici√≥n'])) {
      keywords.add('alimentaci√≥n');
      keywords.add('comida');
      keywords.add('dieta');
    }
    
    if (_containsAnyKeyword(lowerMessage, ['sue√±o', 'dormir', 'descanso', 'noche'])) {
      keywords.add('sue√±o');
      keywords.add('dormir');
      keywords.add('descanso');
    }
    
    if (_containsAnyKeyword(lowerMessage, ['estr√©s', 'ansiedad', 'relajaci√≥n', 'meditaci√≥n', 'mental'])) {
      keywords.add('meditaci√≥n');
      keywords.add('relajaci√≥n');
      keywords.add('respiraci√≥n');
    }
    
    // Buscar h√°bitos similares para cada palabra clave
    for (final keyword in keywords) {
      try {
        final similarHabits = await _findSimilarHabits(keyword);
        allSimilarHabits.addAll(similarHabits);
      } catch (e) {
        print('Error buscando h√°bitos para keyword "$keyword": $e');
      }
    }
    
    // Remover duplicados y limitar a 10 h√°bitos
    return allSimilarHabits.toSet().take(10).toList();
  }

  Future<String> _buildPrompt({
    required String message,
    String? userId,
    List<ChatMessage>? conversationHistory,
    Map<String, dynamic>? userContext,
  }) async {
    final buffer = StringBuffer();
    
    buffer.writeln('Eres "Vive Good", asistente especializado en prevenci√≥n y manejo de gastritis con enfoque en formaci√≥n de h√°bitos saludables.');
    buffer.writeln('');
    
    buffer.writeln('OBJETIVOS PRINCIPALES:');
    buffer.writeln('‚Ä¢ Identificar indicadores espec√≠ficos de gastritis y factores de riesgo');
    buffer.writeln('‚Ä¢ Proporcionar recomendaciones personalizadas y accionables');
    buffer.writeln('‚Ä¢ Analizar cumplimiento de h√°bitos y sugerir mejoras inteligentes');
    buffer.writeln('‚Ä¢ Educar sobre prevenci√≥n y manejo de s√≠ntomas digestivos');
    buffer.writeln('‚Ä¢ Aplicar metodolog√≠as cient√≠ficas de formaci√≥n de h√°bitos');
    buffer.writeln('');
    
    buffer.writeln('METODOLOG√çAS DE FORMACI√ìN DE H√ÅBITOS:');
    buffer.writeln('‚Ä¢ **Atomic Habits (James Clear)**: Enfoque en cambios peque√±os y consistentes (1% mejor cada d√≠a)');
    buffer.writeln('‚Ä¢ **Habit Stacking**: Vincular nuevos h√°bitos a rutinas existentes');
    buffer.writeln('‚Ä¢ **Regla de los 2 minutos**: Nuevos h√°bitos deben tomar menos de 2 minutos inicialmente');
    buffer.writeln('‚Ä¢ **Cue-Routine-Reward Loop**: Identificar disparadores, rutinas y recompensas');
    buffer.writeln('‚Ä¢ **Implementation Intentions**: Planes espec√≠ficos "Si X, entonces Y"');
    buffer.writeln('‚Ä¢ **Progressive Overload**: Incremento gradual de dificultad/duraci√≥n');
    buffer.writeln('');
    
    buffer.writeln('INDICADORES ESPEC√çFICOS DE GASTRITIS A DETECTAR:');
    buffer.writeln('üîç **S√≠ntomas Primarios:**');
    buffer.writeln('‚Ä¢ Dolor epig√°strico (ardor, punzadas, presi√≥n en "boca del est√≥mago")');
    buffer.writeln('‚Ä¢ Acidez estomacal y reflujo gastroesof√°gico');
    buffer.writeln('‚Ä¢ N√°useas matutinas o post-comida');
    buffer.writeln('‚Ä¢ Sensaci√≥n de plenitud temprana o distensi√≥n abdominal');
    buffer.writeln('‚Ä¢ P√©rdida de apetito o aversi√≥n a ciertos alimentos');
    buffer.writeln('');
    buffer.writeln('‚ö†Ô∏è **Factores de Riesgo Cr√≠ticos:**');
    buffer.writeln('‚Ä¢ Infecci√≥n por H. pylori (antecedentes familiares, √∫lceras previas)');
    buffer.writeln('‚Ä¢ Uso prolongado de AINEs (ibuprofeno, aspirina, diclofenaco)');
    buffer.writeln('‚Ä¢ Consumo excesivo de alcohol o tabaco');
    buffer.writeln('‚Ä¢ Estr√©s cr√≥nico y ansiedad');
    buffer.writeln('‚Ä¢ Patrones alimentarios irregulares (ayunos prolongados, comidas tard√≠as)');
    buffer.writeln('‚Ä¢ Consumo frecuente de alimentos irritantes (picantes, √°cidos, procesados)');
    buffer.writeln('');
    buffer.writeln('üçÉ **Alimentos y H√°bitos Protectores:**');
    buffer.writeln('‚Ä¢ Fibra soluble: avena, manzana, pera, zanahoria');
    buffer.writeln('‚Ä¢ Probi√≥ticos: yogur natural, k√©fir, chucrut');
    buffer.writeln('‚Ä¢ Antiinflamatorios naturales: jengibre, c√∫rcuma, manzanilla');
    buffer.writeln('‚Ä¢ T√©cnicas de masticaci√≥n lenta y porciones peque√±as');
    buffer.writeln('‚Ä¢ Horarios regulares de comida (cada 3-4 horas)');
    buffer.writeln('');
    
    buffer.writeln('FORMATO DE RESPUESTA ESTRUCTURADA:');
    buffer.writeln('Responde SIEMPRE en el siguiente formato JSON:');
    buffer.writeln('{');
    buffer.writeln('  "message": "Respuesta conversacional y emp√°tica para el usuario",');
    buffer.writeln('  "actions": {');
    buffer.writeln('    "habit_completion": {');
    buffer.writeln('      "habit_id": "ID del h√°bito si aplica",');
    buffer.writeln('      "status": "complete|partial|none",');
    buffer.writeln('      "completion_percentage": 0-100,');
    buffer.writeln('      "notes": "Observaciones sobre el cumplimiento"');
    buffer.writeln('    },');
    buffer.writeln('    "habit_modification": {');
    buffer.writeln('      "habit_id": "ID del h√°bito a modificar",');
    buffer.writeln('      "action": "extend|adjust_frequency|modify_schedule",');
    buffer.writeln('      "suggestion": "Descripci√≥n de la modificaci√≥n sugerida",');
    buffer.writeln('      "methodology": "Metodolog√≠a aplicada (atomic_habits, habit_stacking, etc.)"');
    buffer.writeln('    },');
    buffer.writeln('    "new_habits": [');
    buffer.writeln('      {');
    buffer.writeln('        "name": "Nombre del h√°bito",');
    buffer.writeln('        "description": "Descripci√≥n detallada",');
    buffer.writeln('        "frequency": "daily|weekly|custom",');
    buffer.writeln('        "methodology": "Metodolog√≠a recomendada"');
    buffer.writeln('      }');
    buffer.writeln('    ]');
    buffer.writeln('  },');
    buffer.writeln('  "methodology_applied": "Metodolog√≠a principal utilizada en la respuesta"');
    buffer.writeln('}');
    buffer.writeln('');
    buffer.writeln('INSTRUCCIONES PARA MANEJO INTELIGENTE DE H√ÅBITOS:');
    buffer.writeln('‚Ä¢ **NUEVOS H√ÅBITOS**: Incluye recomendaciones que puedan convertirse en h√°bitos trackeable');
    buffer.writeln('‚Ä¢ **REPROGRAMACIONES**: Si el usuario menciona cambios de horario, ajustes o modificaciones de h√°bitos existentes, indica claramente "REPROGRAMAR:" seguido del h√°bito y nuevo horario');
    buffer.writeln('‚Ä¢ **FRECUENCIAS**: Especifica frecuencias claras (diario, cada 3 horas, antes de comidas, semanal)');
    buffer.writeln('‚Ä¢ **HORARIOS**: Menciona horarios espec√≠ficos cuando sea apropiado (7:00 AM, antes del almuerzo, 30 min antes de dormir)');
    buffer.writeln('‚Ä¢ **ACCIONES**: Usa verbos de acci√≥n claros ("tomar", "evitar", "practicar", "consumir", "reprogramar", "ajustar")');
    buffer.writeln('‚Ä¢ **PRIORIDAD**: Prioriza h√°bitos simples, medibles y sostenibles');
    buffer.writeln('‚Ä¢ **FORMATO ESPECIAL**: Para reprogramaciones usa: "REPROGRAMAR: [Nombre del h√°bito] - Nuevo horario: [hora] - Motivo: [raz√≥n]"');
    buffer.writeln('');
    buffer.writeln('REGLAS DE FORMATO IMPORTANTES:');
    buffer.writeln('‚Ä¢ NO uses emojis mezclados en medio de las oraciones');
    buffer.writeln('‚Ä¢ Si usas emojis, col√≥calos SOLO al inicio de secciones principales');
    buffer.writeln('‚Ä¢ Evita s√≠mbolos especiales que puedan causar problemas de procesamiento');
    buffer.writeln('‚Ä¢ Usa texto limpio y claro, f√°cil de procesar por sistemas de voz');
    buffer.writeln('‚Ä¢ Mant√©n la estructura simple y consistente');
    buffer.writeln('');
    buffer.writeln('L√çMITES: M√°ximo 200 palabras, tono profesional pero c√°lido.');
    buffer.writeln('');
    
    // Manejo espec√≠fico de mensajes predefinidos
    buffer.writeln('MANEJO DE MENSAJES PREDEFINIDOS:');
    if (message.contains('Quiero registrar mi alimentaci√≥n de hoy')) {
      buffer.writeln('‚Ä¢ El usuario quiere registrar su alimentaci√≥n. Responde con: "¬øQu√© alimentos has consumido hoy? Puedes contarme sobre tu desayuno, almuerzo, cena y cualquier snack que hayas tomado."');
    } else if (message.contains('Tengo s√≠ntomas despu√©s de comer')) {
      buffer.writeln('‚Ä¢ El usuario tiene s√≠ntomas post-comida. Responde con: "¬øQu√© s√≠ntomas espec√≠ficos sientes despu√©s de comer? ¬øCu√°ndo comenzaron y con qu√© frecuencia los experimentas?"');
    } else if (message.contains('Necesito evaluar mis rutinas diarias')) {
      buffer.writeln('‚Ä¢ El usuario quiere evaluar rutinas. Responde con: "¬øPodr√≠as contarme sobre tu rutina diaria actual? Me interesa conocer tus horarios de comida, ejercicio, sue√±o y cualquier h√°bito que consideres importante."');
    } else if (message.contains('Quiero consejos para mejorar mi estilo de vida')) {
      buffer.writeln('‚Ä¢ El usuario busca consejos generales. Responde con: "¬øEn qu√© √°rea espec√≠fica te gustar√≠a mejorar? Por ejemplo: alimentaci√≥n, ejercicio, manejo del estr√©s, calidad del sue√±o, o digesti√≥n."');
    }
    buffer.writeln('');
    
    // Obtener nombres de h√°bitos existentes del usuario para evitar duplicados
    final existingHabitNames = await _getUserExistingHabits(userId);
    if (existingHabitNames.isNotEmpty) {
      buffer.writeln('H√ÅBITOS EXISTENTES DEL USUARIO (NO SUGERIR DUPLICADOS):');
      buffer.writeln(existingHabitNames.join(', '));
      buffer.writeln('');
      buffer.writeln('IMPORTANTE: NO sugieras h√°bitos que el usuario ya tiene adoptados. En su lugar:');
      buffer.writeln('‚Ä¢ Sugiere variaciones o mejoras de los h√°bitos existentes');
      buffer.writeln('‚Ä¢ Prop√≥n nuevos h√°bitos complementarios');
      buffer.writeln('‚Ä¢ Si el usuario quiere modificar un h√°bito existente, usa el formato REPROGRAMAR');
      buffer.writeln('');
    }
    
    // An√°lisis contextual del mensaje del usuario
    final messageAnalysis = _analyzeUserMessage(message);
    if (messageAnalysis.isNotEmpty) {
      buffer.writeln('AN√ÅLISIS DEL MENSAJE ACTUAL:');
      messageAnalysis.forEach((key, value) {
        buffer.writeln('‚Ä¢ $key: $value');
      });
      buffer.writeln('');
    }

    // Obtener h√°bitos similares disponibles basados en el mensaje
    final similarHabits = await _getSimilarHabitsForMessage(message);
    if (similarHabits.isNotEmpty) {
      buffer.writeln('H√ÅBITOS SIMILARES DISPONIBLES (puedes sugerir estos):');
      buffer.writeln(similarHabits.join(', '));
      buffer.writeln('');
    }
    
    if (userContext != null && userContext.isNotEmpty) {
      buffer.writeln('CONTEXTO DEL USUARIO:');
      userContext.forEach((key, value) {
        buffer.writeln('‚Ä¢ $key: $value');
      });
      buffer.writeln('');
    }
    
    if (conversationHistory != null && conversationHistory.isNotEmpty) {
      buffer.writeln('HISTORIAL RECIENTE (para continuidad):');
      for (final msg in conversationHistory.take(3)) {
        final sender = msg.type == MessageType.user ? 'Usuario' : 'Asistente';
        final preview = msg.content.length > 100 ? '${msg.content.substring(0, 100)}...' : msg.content;
        buffer.writeln('$sender: $preview');
      }
      buffer.writeln('');
    }
    
    buffer.writeln('MENSAJE DEL USUARIO: "$message"');
    buffer.writeln('');
    buffer.writeln('RESPONDE AHORA siguiendo EXACTAMENTE la estructura requerida:');
    
    return buffer.toString();
  }
  
  /// Analiza el mensaje del usuario para extraer contexto relevante
  Map<String, String> _analyzeUserMessage(String message) {
    final analysis = <String, String>{};
    final lowerMessage = message.toLowerCase();
    
    // Detectar urgencia
    if (_containsAnyKeyword(lowerMessage, ['urgente', 'dolor fuerte', 'muy mal', 'insoportable'])) {
      analysis['Urgencia'] = 'Alta - requiere atenci√≥n inmediata';
    } else if (_containsAnyKeyword(lowerMessage, ['molesto', 'inc√≥modo', 'frecuente'])) {
      analysis['Urgencia'] = 'Media - s√≠ntomas recurrentes';
    }
    
    // Detectar momento del d√≠a
    if (_containsAnyKeyword(lowerMessage, ['ma√±ana', 'desayuno', 'levantarme'])) {
      analysis['Momento'] = 'Matutino - considerar h√°bitos de ma√±ana';
    } else if (_containsAnyKeyword(lowerMessage, ['noche', 'cena', 'dormir'])) {
      analysis['Momento'] = 'Nocturno - enfocar en rutina vespertina';
    }
    
    // Detectar relaci√≥n con comidas
    if (_containsAnyKeyword(lowerMessage, ['despu√©s de comer', 'tras la comida', 'post comida'])) {
      analysis['Relaci√≥n con comidas'] = 'Post-prandial - s√≠ntomas despu√©s de comer';
    } else if (_containsAnyKeyword(lowerMessage, ['antes de comer', 'en ayunas', 'est√≥mago vac√≠o'])) {
      analysis['Relaci√≥n con comidas'] = 'Pre-prandial - s√≠ntomas con est√≥mago vac√≠o';
    }
    
    // Detectar duraci√≥n de s√≠ntomas
    if (_containsAnyKeyword(lowerMessage, ['hace d√≠as', 'hace semanas', 'hace tiempo', 'cr√≥nico'])) {
      analysis['Duraci√≥n'] = 'Cr√≥nica - s√≠ntomas persistentes';
    } else if (_containsAnyKeyword(lowerMessage, ['hoy', 'ahora', 'reci√©n', 'de repente'])) {
      analysis['Duraci√≥n'] = 'Aguda - s√≠ntomas recientes';
    }
    
    return analysis;
  }
  
  /// Verifica si el texto contiene alguna palabra clave
  bool _containsAnyKeyword(String text, List<String> keywords) {
    return keywords.any((keyword) => text.contains(keyword));
  }

  Future<String> _getGeminiResponse(
    String message,
    String userId,
    List<ChatMessage> conversationHistory,
  ) async {
    const maxRetries = 3;
    const retryDelay = Duration(seconds: 2);
    
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        print('üöÄ Intento $attempt/$maxRetries - Enviando solicitud a Gemini API...');
        
        final response = await _makeGeminiRequest(message, userId, conversationHistory);
        return response;
        
      } catch (e) {
        print('‚ùå Intento $attempt fall√≥: $e');
        
        if (attempt == maxRetries) {
          print('üí• Todos los intentos fallaron');
          rethrow;
        }
        
        // Solo reintentar en ciertos tipos de errores
        if (_shouldRetry(e)) {
          print('‚è≥ Esperando ${retryDelay.inSeconds} segundos antes del siguiente intento...');
          await Future.delayed(retryDelay);
        } else {
          print('üö´ Error no recuperable, no se reintentar√°');
          rethrow;
        }
      }
    }
    
    throw Exception('Error inesperado en el sistema de reintentos');
  }
  
  bool _shouldRetry(dynamic error) {
    final errorString = error.toString().toLowerCase();
    return errorString.contains('timeout') ||
           errorString.contains('socket') ||
           errorString.contains('connection') ||
           errorString.contains('500') ||
           errorString.contains('502') ||
           errorString.contains('503');
  }
  
  Future<String> _makeGeminiRequest(
    String message,
    String userId,
    List<ChatMessage> conversationHistory,
  ) async {
    final prompt = await _buildPrompt(
      message: message,
      userId: userId,
      conversationHistory: conversationHistory,
    );
    
    final requestBody = {
      'contents': [{
        'parts': [{
          'text': prompt
        }]
      }],
      'generationConfig': {
        'temperature': 0.7,
        'topK': 40,
        'topP': 0.95,
        'maxOutputTokens': 2048, // Aumentado para permitir respuestas m√°s largas
      },
      'safetySettings': [
        {
          'category': 'HARM_CATEGORY_HARASSMENT',
          'threshold': 'BLOCK_MEDIUM_AND_ABOVE'
        },
        {
          'category': 'HARM_CATEGORY_HATE_SPEECH',
          'threshold': 'BLOCK_MEDIUM_AND_ABOVE'
        },
        {
          'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
          'threshold': 'BLOCK_MEDIUM_AND_ABOVE'
        },
        {
          'category': 'HARM_CATEGORY_DANGEROUS_CONTENT',
          'threshold': 'BLOCK_MEDIUM_AND_ABOVE'
        }
      ]
    };

    try {
      print('üìù Prompt length: ${prompt.length} characters');
      print('üîë API Key configured: ${_apiKey.isNotEmpty ? "Yes" : "No"}');
      
      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/models/gemini-2.5-flash:generateContent?key=$_apiKey'),
        headers: {
          'Content-Type': 'application/json',
        },
        body: jsonEncode(requestBody),
      ).timeout(const Duration(seconds: 60));

      print('üì° Gemini API response status: ${response.statusCode}');
      
      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        final geminiText = responseData['candidates']?[0]?['content']?['parts']?[0]?['text'] ?? 'Lo siento, no pude procesar tu mensaje.';
        print('‚úÖ Gemini response received: ${geminiText.length} characters');
        return geminiText;
      } else {
         // Logging detallado del error
         print('‚ùå Gemini API Error - Status: ${response.statusCode}');
         print('üìÑ Response body: ${response.body}');
         
         _logError('gemini_api', 'generateContent', 'HTTP ${response.statusCode}', {
           'status_code': response.statusCode,
           'response_body': response.body,
           'api_endpoint': '$_baseUrl/models/gemini-2.5-flash:generateContent',
           'has_api_key': _apiKey.isNotEmpty,
         });
         
         // Manejo espec√≠fico de errores
         switch (response.statusCode) {
           case 400:
             throw Exception('Solicitud inv√°lida a la API de Gemini. Verifica el formato del mensaje.');
           case 401:
             throw Exception('API key de Gemini inv√°lida o expirada. Contacta al administrador.');
           case 403:
             throw Exception('Sin permisos para usar la API de Gemini. Verifica tu cuenta.');
           case 404:
             throw Exception('Endpoint de la API de Gemini no encontrado. Verifica la configuraci√≥n.');
           case 429:
             throw Exception('L√≠mite de solicitudes excedido. Intenta de nuevo en unos minutos.');
           case 500:
           case 502:
           case 503:
             throw Exception('Servicio de Gemini temporalmente no disponible. Intenta m√°s tarde.');
           default:
             throw Exception('Error en la API de Gemini: ${response.statusCode} - ${response.body}');
         }
       }
    } catch (e) {
       print('üí• Gemini API Exception: $e');
       
       if (e.toString().contains('TimeoutException')) {
         print('‚è∞ Timeout error detected');
         _logError('gemini_api', 'generateContent', 'Timeout', {
           'error_type': 'timeout',
           'timeout_duration': '60 seconds',
         });
         throw Exception('Timeout al conectar con la API de Gemini. Verifica tu conexi√≥n.');
       }
       if (e.toString().contains('SocketException')) {
         print('üåê Socket/Connection error detected');
         _logError('gemini_api', 'generateContent', 'Connection Error', {
           'error_type': 'socket_exception',
           'error_details': e.toString(),
         });
         throw Exception('Error de conexi√≥n con la API de Gemini. Verifica tu internet.');
       }
       
       // Log de error general
       _logError('gemini_api', 'generateContent', 'Unexpected Error', {
         'error_type': 'unexpected',
         'error_details': e.toString(),
       });
       rethrow;
     }
  }

  Future<DeepLearningAnalysis> _getDeepLearningAnalysis(
    String message,
    String userId,
  ) async {
    if (_deepLearningDatasource == null) {
      throw Exception('Deep Learning datasource no disponible');
    }

    // Extraer informaci√≥n relevante del mensaje para el an√°lisis
    final userHabits = _extractHabitsFromMessage(message);
    
    // Usar el nuevo m√©todo predictGastritisRisk en lugar de analyzeGastritisRisk
    final prediction = await _deepLearningDatasource!.predictGastritisRisk(
      userId: userId,
      userHabits: userHabits,
    );
    
    // Convertir GastritisRiskPrediction a DeepLearningAnalysis
    return DeepLearningAnalysis(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      userId: prediction.userId,
      type: AnalysisType.gastritisRisk,
      inputData: userHabits,
      results: {
        'risk_level': prediction.riskLevel,
        'risk_category': prediction.riskCategory,
        'factor_contributions': prediction.factorContributions,
        'risk_factors': prediction.riskFactors,
      },
      riskLevel: _mapRiskLevel(prediction.riskCategory),
      confidence: prediction.confidence,
      recommendations: [], // Se obtendr√°n por separado
      timestamp: prediction.timestamp,
      modelVersion: '1.0.0',
    );
  }

  /// Obtiene respuesta del backend de deep learning usando predicci√≥n y recomendaciones
  Future<Map<String, dynamic>?> _getDeepLearningChatResponse(
    String message,
    String userId,
    String? sessionId,
  ) async {
    if (_deepLearningDatasource == null) {
      print('‚ö†Ô∏è Deep Learning datasource no disponible');
      return null;
    }

    try {
      print('ü§ñ Iniciando an√°lisis de Deep Learning para usuario: $userId');
      
      final extractedSymptoms = _extractSymptomsFromMessage(message);
      final extractedHabits = _extractHabitsFromMessage(message);

      print('üìä S√≠ntomas extra√≠dos: ${extractedSymptoms.keys.join(", ")}');
      print('üîç H√°bitos detectados: ${extractedHabits.keys.join(", ")}');

      // Obtener predicci√≥n de riesgo de gastritis
      final prediction = await _deepLearningDatasource!.predictGastritisRisk(
        userId: userId,
        userHabits: extractedHabits,
      ).timeout(const Duration(seconds: 15));
      
      // Obtener recomendaciones de h√°bitos
      final recommendations = await _deepLearningDatasource!.getHabitRecommendations(
        userId: userId,
        currentHabits: extractedHabits,
        riskLevel: prediction.riskLevel,
      ).timeout(const Duration(seconds: 10));
      
      print('‚úÖ Respuesta de Deep Learning recibida exitosamente');
      
      // Crear respuesta estructurada similar al formato anterior
      return {
        'response_type': 'prediction',
        'message': 'An√°lisis de riesgo de gastritis completado',
        'risk_assessment': {
          'level': prediction.riskCategory,
          'score': prediction.riskLevel,
          'factors': prediction.riskFactors,
          'confidence': prediction.confidence,
        },
        'suggested_actions': recommendations.map((r) => r.title).toList(),
        'detailed_recommendations': recommendations.map((r) => {
          'title': r.title,
          'description': r.description,
          'category': r.category,
          'priority': r.priority,
          'impact_score': r.impactScore,
          'action_steps': r.actionSteps,
          'timeframe': r.timeframe,
        }).toList(),
        'timestamp': prediction.timestamp.toIso8601String(),
        'status': 'success',
      };
      
    } on TimeoutException {
      print('‚è∞ Timeout en llamada a Deep Learning backend (15s)');
      return _createFallbackDLResponse(message, extractedSymptoms: _extractSymptomsFromMessage(message));
    } on SocketException catch (e) {
      print('üåê Error de conexi√≥n con Deep Learning backend: $e');
      return _createFallbackDLResponse(message, extractedSymptoms: _extractSymptomsFromMessage(message));
    } catch (e, stackTrace) {
      print('‚ùå Error inesperado en Deep Learning: $e');
      print('üìç Stack trace: $stackTrace');
      return _createFallbackDLResponse(message, extractedSymptoms: _extractSymptomsFromMessage(message));
    }
  }

  /// Extrae s√≠ntomas del mensaje del usuario con an√°lisis mejorado
  Map<String, dynamic> _extractSymptomsFromMessage(String message) {
    final symptoms = <String, dynamic>{};
    final lowerMessage = message.toLowerCase();
    
    // Detectar dolor de est√≥mago con intensidad
    if (lowerMessage.contains('dolor') && (lowerMessage.contains('est√≥mago') || lowerMessage.contains('estomago'))) {
      symptoms['stomach_pain'] = true;
      symptoms['pain_duration'] = _extractDuration(lowerMessage);
      symptoms['pain_intensity'] = _extractIntensity(lowerMessage);
    }
    
    // Acidez y agruras
    if (lowerMessage.contains('acidez') || lowerMessage.contains('agruras') || lowerMessage.contains('reflujo')) {
      symptoms['heartburn'] = true;
      symptoms['heartburn_frequency'] = _extractFrequency(lowerMessage);
    }
    
    // N√°useas y v√≥mitos
    if (lowerMessage.contains('n√°usea') || lowerMessage.contains('nausea') || 
        lowerMessage.contains('ganas de vomitar') || lowerMessage.contains('v√≥mito')) {
      symptoms['nausea'] = true;
    }
    
    // Hinchaz√≥n e inflamaci√≥n
    if (lowerMessage.contains('hinchaz√≥n') || lowerMessage.contains('inflamado') || 
        lowerMessage.contains('distensi√≥n') || lowerMessage.contains('pesadez')) {
      symptoms['bloating'] = true;
    }
    
    // S√≠ntomas adicionales
    if (lowerMessage.contains('ardor') || lowerMessage.contains('quemaz√≥n')) {
      symptoms['burning_sensation'] = true;
    }
    
    if (lowerMessage.contains('inapetencia') || lowerMessage.contains('sin apetito') || 
        lowerMessage.contains('no tengo hambre')) {
      symptoms['loss_of_appetite'] = true;
    }
    
    return symptoms;
  }

  /// Extrae duraci√≥n de s√≠ntomas del mensaje
  String _extractDuration(String message) {
    if (message.contains('semana')) return 'weekly';
    if (message.contains('d√≠a') || message.contains('dias')) return 'daily';
    if (message.contains('mes')) return 'monthly';
    if (message.contains('hora')) return 'hourly';
    if (message.contains('momento') || message.contains('ahora')) return 'current';
    if (message.contains('cr√≥nico') || message.contains('siempre')) return 'chronic';
    return 'unknown';
  }
  
  /// Extrae intensidad del dolor del mensaje
  String _extractIntensity(String message) {
    if (message.contains('mucho') || message.contains('intenso') || message.contains('fuerte')) return 'high';
    if (message.contains('poco') || message.contains('leve') || message.contains('ligero')) return 'low';
    if (message.contains('moderado') || message.contains('regular')) return 'medium';
    return 'unknown';
  }
  
  /// Extrae frecuencia de s√≠ntomas del mensaje
  String _extractFrequency(String message) {
    if (message.contains('siempre') || message.contains('constantemente')) return 'constant';
    if (message.contains('frecuente') || message.contains('seguido')) return 'frequent';
    if (message.contains('ocasional') || message.contains('a veces')) return 'occasional';
    if (message.contains('rara vez') || message.contains('pocas veces')) return 'rare';
    return 'unknown';
  }
  
  /// Crea una respuesta de fallback cuando Deep Learning no est√° disponible
  Map<String, dynamic> _createFallbackDLResponse(String message, {Map<String, dynamic>? extractedSymptoms}) {
    final symptoms = extractedSymptoms ?? _extractSymptomsFromMessage(message);
    
    return {
      'response_type': 'fallback',
      'message': 'An√°lisis b√°sico realizado localmente',
      'risk_assessment': {
        'level': symptoms.isNotEmpty ? 'medium' : 'low',
        'factors': symptoms.keys.toList(),
        'confidence': 0.6,
      },
      'suggested_actions': [
        'Consultar con un profesional de la salud',
        'Mantener un diario de s√≠ntomas',
        'Seguir una dieta balanceada',
      ],
      'timestamp': DateTime.now().toIso8601String(),
      'status': 'fallback_mode',
    };
  }
  
  /// Crea una respuesta de fallback mejorada con m√°s contexto
  Map<String, dynamic> _createEnhancedFallbackResponse(String message, String userId, String errorContext) {
    final symptoms = _extractSymptomsFromMessage(message);
    final habits = _extractHabitsFromMessage(message);
    
    // An√°lisis m√°s sofisticado del mensaje
    String contextualResponse = '';
    List<String> smartActions = [];
    Map<String, dynamic> riskAssessment = {};
    
    final lowerMessage = message.toLowerCase();
    
    if (lowerMessage.contains('dolor') && (lowerMessage.contains('est√≥mago') || lowerMessage.contains('abdominal'))) {
      contextualResponse = 'üîç **An√°lisis Local:** Detectamos s√≠ntomas gastrointestinales. '
          'Basado en patrones conocidos, te sugerimos medidas preventivas inmediatas.';
      
      smartActions = [
        'Implementar comidas peque√±as y frecuentes',
        'Evitar alimentos irritantes (picantes, √°cidos)',
        'Aplicar t√©cnicas de relajaci√≥n para reducir estr√©s',
        'Mantener hidrataci√≥n adecuada',
      ];
      
      riskAssessment = {
        'level': 'medium',
        'confidence': 0.75,
        'factors': ['s√≠ntomas_gastrointestinales', 'dolor_abdominal'],
        'recommendations': [
          'Monitorear frecuencia e intensidad del dolor',
          'Consulta m√©dica si persisten los s√≠ntomas por m√°s de 48h',
          'Implementar dieta blanda temporalmente',
        ],
      };
    } else if (lowerMessage.contains('estr√©s') || lowerMessage.contains('ansiedad')) {
      contextualResponse = 'üß† **An√°lisis Local:** Identificamos factores de estr√©s que pueden afectar la salud digestiva. '
          'El manejo del estr√©s es clave para prevenir gastritis.';
      
      smartActions = [
        'Practicar t√©cnicas de respiraci√≥n profunda',
        'Establecer rutinas de relajaci√≥n',
        'Mantener horarios regulares de comida',
        'Considerar actividad f√≠sica moderada',
      ];
      
      riskAssessment = {
        'level': 'medium',
        'confidence': 0.70,
        'factors': ['estr√©s_psicol√≥gico', 'impacto_digestivo'],
        'recommendations': [
          'Implementar t√©cnicas de manejo del estr√©s',
          'Evaluar factores estresantes en el entorno',
          'Considerar apoyo profesional si es necesario',
        ],
      };
    } else {
      contextualResponse = 'üí° **An√°lisis Local:** Procesamos tu consulta con nuestro sistema de respaldo. '
          'Te ofrecemos recomendaciones generales para mantener una buena salud digestiva.';
      
      smartActions = [
        'Mantener alimentaci√≥n balanceada y regular',
        'Incorporar ejercicio moderado diariamente',
        'Asegurar descanso adecuado (7-8 horas)',
        'Gestionar niveles de estr√©s efectivamente',
      ];
      
      riskAssessment = {
        'level': 'low',
        'confidence': 0.65,
        'factors': [],
        'recommendations': [
          'Continuar con h√°bitos preventivos',
          'Monitoreo regular de s√≠ntomas',
          'Mantener comunicaci√≥n con profesionales de salud',
        ],
      };
    }
    
    return {
      'message_id': DateTime.now().millisecondsSinceEpoch.toString(),
      'respuesta_modelo': contextualResponse,
      'timestamp': DateTime.now().toIso8601String(),
      'session_id': 'fallback_session_${DateTime.now().millisecondsSinceEpoch}',
      'risk_assessment': riskAssessment,
      'suggested_actions': smartActions,
      'confidence_score': riskAssessment['confidence'] ?? 0.65,
      'processing_time_ms': 50,
      'model_version': '1.0.0-local-fallback',
      'status': 'local_analysis',
      'error_context': errorContext,
      'fallback_reason': 'deep_learning_service_unavailable',
    };
  }
  
  /// Convierte la categor√≠a de riesgo string a RiskLevel enum
  RiskLevel _mapRiskLevel(String riskCategory) {
    switch (riskCategory.toLowerCase()) {
      case 'low':
      case 'bajo':
        return RiskLevel.low;
      case 'medium':
      case 'moderate':
      case 'moderado':
      case 'medio':
        return RiskLevel.medium;
      case 'high':
      case 'alto':
        return RiskLevel.high;
      case 'critical':
      case 'critico':
      case 'cr√≠tico':
        return RiskLevel.critical;
      default:
        return RiskLevel.low;
    }
  }

  /// Registra errores de Deep Learning para m√©tricas y debugging
  void _logDeepLearningError(String operation, String error) {
    _logError('deep_learning', operation, error, {
      'dl_service_available': _deepLearningDatasource != null,
    });
  }

  /// M√©todo general de logging de errores con contexto detallado
  void _logError(String service, String operation, String error, [Map<String, dynamic>? context]) {
    final errorLog = {
      'timestamp': DateTime.now().toIso8601String(),
      'service': service,
      'operation': operation,
      'error': error,
      'context': context ?? {},
      'user_agent': 'ViveGood_Flutter_App',
      'version': '1.0.0',
    };
    
    // Logging detallado para debugging
    print('üö® ===== ERROR LOG =====');
    print('üïê Timestamp: ${errorLog['timestamp']}');
    print('üîß Service: ${errorLog['service']}');
    print('‚öôÔ∏è Operation: ${errorLog['operation']}');
    print('‚ùå Error: ${errorLog['error']}');
    if (context != null && context.isNotEmpty) {
      print('üìã Context: ${errorLog['context']}');
    }
    print('üö® =====================');
    
    // En un entorno de producci√≥n, esto se enviar√≠a a un servicio de logging
    // TODO: Implementar env√≠o a servicio de m√©tricas/logging
    // await _metricsService.logError(errorLog);
  }

  String _combineResponses(
    String geminiResponse,
    DeepLearningAnalysis analysis,
  ) {
    final buffer = StringBuffer();
    
    // Agregar respuesta de Gemini
    buffer.writeln(geminiResponse);
    buffer.writeln();
    
    // Agregar an√°lisis de Deep Learning
    buffer.writeln('üìä **An√°lisis de Riesgo:**');
    buffer.writeln('‚Ä¢ Nivel de riesgo: ${_getRiskLevelText(analysis.riskLevel)}');
    buffer.writeln('‚Ä¢ Confianza: ${(analysis.confidence * 100).toStringAsFixed(1)}%');
    
    if (analysis.identifiedRiskFactors?.isNotEmpty == true) {
      buffer.writeln();
      buffer.writeln('‚ö†Ô∏è **Factores de riesgo identificados:**');
      for (final factor in analysis.identifiedRiskFactors!) {
        buffer.writeln('‚Ä¢ $factor');
      }
    }
    
    if (analysis.recommendations.isNotEmpty) {
      buffer.writeln();
      buffer.writeln('üí° **Recomendaciones personalizadas:**');
      for (final recommendation in analysis.recommendations) {
        buffer.writeln('‚Ä¢ $recommendation');
      }
    }
    
    return buffer.toString();
  }

  /// Combina respuestas de Gemini, chat de Deep Learning y an√°lisis
  String _combineAllResponses(
    String geminiResponse,
    Map<String, dynamic>? dlChatResponse,
    DeepLearningAnalysis? dlAnalysis,
  ) {
    final buffer = StringBuffer();
    
    // Formatear respuesta de Gemini (eliminar marcadores markdown y resaltar palabras clave)
    final formattedGemini = _formatGeminiResponse(geminiResponse);
    buffer.writeln(formattedGemini);
    
    // Agregar informaci√≥n del chat de Deep Learning si est√° disponible
    if (dlChatResponse != null) {
      buffer.writeln();
      buffer.writeln('ü§ñ **An√°lisis Inteligente:**');
      
      if (dlChatResponse['risk_assessment'] != null) {
        final riskAssessment = dlChatResponse['risk_assessment'];
        buffer.writeln('‚Ä¢ Evaluaci√≥n de riesgo: ${riskAssessment['level'] ?? 'No determinado'}');
        if (riskAssessment['factors'] != null) {
          buffer.writeln('‚Ä¢ Factores identificados: ${(riskAssessment['factors'] as List).join(', ')}');
        }
      }
      
      if (dlChatResponse['suggested_actions'] != null) {
        buffer.writeln();
        buffer.writeln('üí° **Acciones Recomendadas:**');
        final actions = dlChatResponse['suggested_actions'] as List;
        for (final action in actions) {
          buffer.writeln('‚Ä¢ $action');
        }
      }
      
      final confidence = dlChatResponse['confidence_score'];
      if (confidence != null) {
        buffer.writeln();
        buffer.writeln('üìä Confianza del an√°lisis: ${(confidence * 100).toStringAsFixed(1)}%');
      }
    }
    
    // Agregar an√°lisis tradicional como fallback
    if (dlAnalysis != null && dlChatResponse == null) {
      buffer.writeln();
      buffer.writeln('üìä **An√°lisis de Riesgo:**');
      buffer.writeln('‚Ä¢ Nivel de riesgo: ${_getRiskLevelText(dlAnalysis.riskLevel)}');
      buffer.writeln('‚Ä¢ Confianza: ${(dlAnalysis.confidence * 100).toStringAsFixed(1)}%');
      
      if (dlAnalysis.identifiedRiskFactors?.isNotEmpty == true) {
        buffer.writeln();
        buffer.writeln('‚ö†Ô∏è **Factores de riesgo identificados:**');
        for (final factor in dlAnalysis.identifiedRiskFactors!) {
          buffer.writeln('‚Ä¢ $factor');
        }
      }
      
      if (dlAnalysis.recommendations.isNotEmpty) {
        buffer.writeln();
        buffer.writeln('üí° **Recomendaciones personalizadas:**');
        for (final recommendation in dlAnalysis.recommendations) {
          buffer.writeln('‚Ä¢ $recommendation');
        }
      }
    }
    
    return buffer.toString();
  }

  /// Formatea la respuesta de Gemini eliminando marcadores markdown y aplicando formato de texto
  String _formatGeminiResponse(String response) {
    print('üî• DEBUG FORMATEO: Respuesta original de Gemini:');
    print('üî• DEBUG FORMATEO: "$response"');
    
    // Normalizar el texto primero
    String normalized = response
        .replaceAll(RegExp(r'\n\s*\n\s*\n'), '\n\n') // M√°ximo 2 saltos de l√≠nea consecutivos
        .replaceAll(RegExp(r'[ \t]+'), ' ') // Normalizar espacios
        .replaceAll(RegExp(r'^[‚Ä¢*-]\s*', multiLine: true), '‚Ä¢ ') // Unificar bullets
        .replaceAllMapped(RegExp(r'^\s*\d+\.\s+(.+)$', multiLine: true), (match) {
          print('üî• DEBUG REGEX: Match encontrado: "${match.group(0)}"');
          print('üî• DEBUG REGEX: Grupo 1: "${match.group(1)}"');
          return '‚Ä¢ ${match.group(1)}';
        }) // Convertir listas numeradas
        .replaceAllMapped(RegExp(r'^#{1,3}\s*(.+)', multiLine: true), (match) => match.group(1)!) // Limpiar t√≠tulos
        .trim();
    
    print('üî• DEBUG FORMATEO: Despu√©s de normalizaci√≥n:');
    print('üî• DEBUG FORMATEO: "$normalized"');

    // Eliminar marcadores markdown y aplicar formato de texto
    String formatted = normalized
        .replaceAllMapped(RegExp(r'\*\*([^*]+?)\*\*'), (match) => match.group(1)!) // Eliminar negritas **texto**
        .replaceAllMapped(RegExp(r'\*([^*]+?)\*'), (match) => match.group(1)!) // Eliminar cursivas *texto*
        .replaceAllMapped(RegExp(r'__([^_]+?)__'), (match) => match.group(1)!) // Eliminar negritas __texto__
        .replaceAllMapped(RegExp(r'_([^_]+?)_'), (match) => match.group(1)!); // Eliminar cursivas _texto_

    print('üî• DEBUG FORMATEO: Despu√©s de eliminar markdown:');
    print('üî• DEBUG FORMATEO: "$formatted"');

    // Resaltar palabras clave m√©dicas importantes con emojis
    formatted = _highlightMedicalKeywords(formatted);

    print('üî• DEBUG FORMATEO: Resultado final:');
    print('üî• DEBUG FORMATEO: "$formatted"');

    return formatted;
  }

  /// Resalta palabras clave m√©dicas importantes con formato limpio
  String _highlightMedicalKeywords(String text) {
    // Solo resaltar palabras clave cr√≠ticas sin emojis mezclados
    final criticalKeywords = {
      'gastritis': 'GASTRITIS',
      '√∫lcera': '√öLCERA',
    };

    String highlighted = text;
    
    // Aplicar resaltado solo a palabras cr√≠ticas, sin emojis mezclados
    criticalKeywords.forEach((keyword, replacement) {
      final regex = RegExp(r'\b' + RegExp.escape(keyword) + r'\b', caseSensitive: false);
      highlighted = highlighted.replaceAllMapped(regex, (match) => '**$replacement**');
    });

    return highlighted;
  }



  /// Extrae h√°bitos sugeridos de la respuesta de Gemini para creaci√≥n autom√°tica
  List<Map<String, dynamic>> _extractHabitsFromGeminiResponse(String response) {
    final habits = <Map<String, dynamic>>[];
    final lines = response.split('\n');
    
    for (final line in lines) {
      final trimmedLine = line.trim();
      
      // Detectar l√≠neas que contienen recomendaciones de h√°bitos
      if (_isHabitRecommendation(trimmedLine)) {
        final habit = _parseHabitFromLine(trimmedLine);
        if (habit != null) {
          habits.add(habit);
        }
      }
    }
    
    return habits;
  }

  /// Determina si una l√≠nea contiene una recomendaci√≥n de h√°bito
  bool _isHabitRecommendation(String line) {
    final lowerLine = line.toLowerCase();
    
    // Patrones que indican recomendaciones de h√°bitos
    final patterns = [
      'comidas peque√±as',
      'evita',
      'evitar',
      'consume',
      'incluye',
      'bebe',
      'toma',
      'realiza',
      'practica',
      'mant√©n',
      'establece',
      'horarios',
      'frecuencia',
    ];
    
    return patterns.any((pattern) => lowerLine.contains(pattern)) &&
           (line.startsWith('‚Ä¢') || line.startsWith('*') || line.startsWith('-'));
  }

  /// Parsea un h√°bito desde una l√≠nea de texto
  Map<String, dynamic>? _parseHabitFromLine(String line) {
    // Limpiar la l√≠nea de marcadores
    String cleanLine = line
        .replaceAll(RegExp(r'^[‚Ä¢*-]\s*'), '')
        .replaceAll(RegExp(r'\*\*([^*]+)\*\*'), r'$1')
        .replaceAll(RegExp(r'\*([^*]+)\*'), r'$1')
        .trim();
    
    if (cleanLine.isEmpty) return null;
    
    // Determinar categor√≠a y tipo de h√°bito
    final category = _determineHabitCategory(cleanLine);
    final type = _determineHabitType(cleanLine);
    
    return {
      'name': cleanLine,
      'description': 'Recomendaci√≥n generada autom√°ticamente por el asistente',
      'category': category,
      'type': type,
      'frequency': _suggestFrequency(cleanLine),
      'auto_generated': true,
      'source': 'gemini_recommendation',
    };
  }

  /// Determina la categor√≠a del h√°bito
  String _determineHabitCategory(String habit) {
    final lowerHabit = habit.toLowerCase();
    
    if (lowerHabit.contains('comida') || lowerHabit.contains('alimento') || 
        lowerHabit.contains('come') || lowerHabit.contains('consume')) {
      return 'Alimentaci√≥n';
    }
    
    if (lowerHabit.contains('ejercicio') || lowerHabit.contains('actividad') ||
        lowerHabit.contains('camina') || lowerHabit.contains('deporte')) {
      return 'Ejercicio';
    }
    
    if (lowerHabit.contains('agua') || lowerHabit.contains('bebe') ||
        lowerHabit.contains('hidrata')) {
      return 'Hidrataci√≥n';
    }
    
    if (lowerHabit.contains('sue√±o') || lowerHabit.contains('dormir') ||
        lowerHabit.contains('descanso')) {
      return 'Descanso';
    }
    
    if (lowerHabit.contains('estr√©s') || lowerHabit.contains('relajaci√≥n') ||
        lowerHabit.contains('meditaci√≥n')) {
      return 'Bienestar Mental';
    }
    
    return 'General';
  }

  /// Determina el tipo de h√°bito
  String _determineHabitType(String habit) {
    final lowerHabit = habit.toLowerCase();
    
    if (lowerHabit.contains('evita') || lowerHabit.contains('evitar') ||
        lowerHabit.contains('no') || lowerHabit.contains('reduce')) {
      return 'Evitar';
    }
    
    return 'Adoptar';
  }

  /// Sugiere frecuencia para el h√°bito
  String _suggestFrequency(String habit) {
    final lowerHabit = habit.toLowerCase();
    
    if (lowerHabit.contains('diario') || lowerHabit.contains('cada d√≠a') ||
        lowerHabit.contains('todos los d√≠as')) {
      return 'Diario';
    }
    
    if (lowerHabit.contains('comida') || lowerHabit.contains('alimento')) {
      return 'Con cada comida';
    }
    
    if (lowerHabit.contains('agua') || lowerHabit.contains('hidrata')) {
      return 'Varias veces al d√≠a';
    }
    
    return 'Diario';
  }

  Map<String, dynamic> _extractHabitsFromMessage(String message) {
    final habits = <String, dynamic>{};
    final lowerMessage = message.toLowerCase();
    
    // Detectar frecuencia de comidas picantes
    if (lowerMessage.contains('picante') || lowerMessage.contains('chile') || lowerMessage.contains('aj√≠')) {
      habits['spicy_food_frequency'] = 4; // Frecuente
    }
    
    // Detectar s√≠ntomas de dolor
    if (lowerMessage.contains('dolor') && (lowerMessage.contains('est√≥mago') || lowerMessage.contains('estomago'))) {
      habits['stomach_pain_frequency'] = 5; // Diario durante una semana
    }
    
    // Detectar patrones de alimentaci√≥n
    if (lowerMessage.contains('comida r√°pida') || lowerMessage.contains('fast food')) {
      habits['fast_food_frequency'] = 3;
    }
    
    // Detectar estr√©s
    if (lowerMessage.contains('estr√©s') || lowerMessage.contains('estres') || lowerMessage.contains('ansiedad')) {
      habits['stress_level'] = 4;
    }
    
    return habits;
  }

  List<Map<String, dynamic>> _extractHabitsFromResponse(String content) {
    final habits = <Map<String, dynamic>>[];
    final lines = content.split('\n');
    
    for (final line in lines) {
      final trimmedLine = line.trim();
      
      // Detectar recomendaciones de h√°bitos
      if (trimmedLine.contains('comidas peque√±as') || trimmedLine.contains('porciones m√°s peque√±as')) {
        habits.add({
          'name': 'Comidas peque√±as y frecuentes',
          'description': 'Comer porciones m√°s peque√±as cada 2-3 horas',
          'category': 'alimentacion',
          'frequency': 'daily',
          'times_per_day': 5,
        });
      }
      
      if (trimmedLine.contains('evita') && (trimmedLine.contains('picante') || trimmedLine.contains('irritantes'))) {
        habits.add({
          'name': 'Evitar alimentos irritantes',
          'description': 'Evitar comidas picantes, caf√©, alcohol y c√≠tricos',
          'category': 'alimentacion',
          'frequency': 'daily',
          'is_negative': true,
        });
      }
      
      if (trimmedLine.contains('hidrat') || trimmedLine.contains('agua')) {
        habits.add({
          'name': 'Mantener hidrataci√≥n',
          'description': 'Beber suficiente agua durante el d√≠a',
          'category': 'hidratacion',
          'frequency': 'daily',
          'target_amount': '8 vasos',
        });
      }
    }
    
    return habits;
  }

  String _getRiskLevelText(RiskLevel riskLevel) {
    switch (riskLevel) {
      case RiskLevel.low:
        return 'Bajo üü¢';
      case RiskLevel.medium:
        return 'Medio üü°';
      case RiskLevel.high:
        return 'Alto üü†';
      case RiskLevel.critical:
        return 'Cr√≠tico üî¥';
    }
  }

  double? _extractConfidence(Map<String, dynamic> data) {
    // Gemini no proporciona confidence score directamente
    // Podr√≠amos implementar una heur√≠stica basada en la respuesta
    return 0.85; // Valor por defecto
  }

  /// Extrae sugerencias combinando respuesta de chat DL y an√°lisis tradicional
  List<String> _extractSuggestions(
    Map<String, dynamic>? dlChatResponse,
    DeepLearningAnalysis? dlAnalysis,
  ) {
    final suggestions = <String>[];
    
    // Agregar sugerencias del chat de deep learning
    if (dlChatResponse != null && dlChatResponse['suggested_actions'] != null) {
      final actions = dlChatResponse['suggested_actions'] as List;
      suggestions.addAll(actions.map((action) => action.toString()));
    }
    
    // Agregar recomendaciones del an√°lisis tradicional como fallback
    if (dlAnalysis != null && suggestions.isEmpty) {
      suggestions.addAll(dlAnalysis.recommendations);
    }
    
    // Agregar sugerencias generales si no hay ninguna
    if (suggestions.isEmpty) {
      suggestions.addAll([
        'Mant√©n horarios regulares de comida',
        'Evita alimentos irritantes',
        'Reduce el estr√©s',
        'Consulta con un profesional de la salud',
      ]);
    }
    
    return suggestions;
  }

  /// Crea una respuesta de fallback cuando la API de Gemini no est√° disponible
  String _createGeminiFallbackResponse(String message, String userId, String error) {
    print('üîÑ Generando respuesta de fallback para Gemini');
    
    // Analizar el mensaje para proporcionar una respuesta contextual
    final lowerMessage = message.toLowerCase();
    
    // Respuestas espec√≠ficas para temas de salud digestiva
    if (lowerMessage.contains('dolor') || lowerMessage.contains('est√≥mago') || lowerMessage.contains('gastritis')) {
      return '''Entiendo que tienes molestias estomacales. Aunque no puedo acceder al asistente de IA en este momento, puedo ofrecerte algunos consejos generales:

‚Ä¢ Evita alimentos irritantes como picantes, √°cidos o muy grasosos
‚Ä¢ Come en porciones peque√±as y frecuentes
‚Ä¢ Mant√©n horarios regulares de comida
‚Ä¢ Reduce el estr√©s y practica t√©cnicas de relajaci√≥n
‚Ä¢ Considera consultar con un profesional de la salud

¬øTe gustar√≠a que te ayude a crear un h√°bito espec√≠fico para mejorar tu digesti√≥n?''';
    }
    
    if (lowerMessage.contains('h√°bito') || lowerMessage.contains('rutina') || lowerMessage.contains('crear')) {
      return '''Me encantar√≠a ayudarte a crear nuevos h√°bitos saludables. Aunque el asistente de IA no est√° disponible temporalmente, puedo sugerirte algunos h√°bitos beneficiosos:

‚Ä¢ Beber agua al despertar
‚Ä¢ Caminar 30 minutos diarios
‚Ä¢ Meditar 10 minutos antes de dormir
‚Ä¢ Comer frutas y verduras en cada comida
‚Ä¢ Mantener horarios regulares de sue√±o

¬øCu√°l de estos h√°bitos te interesa m√°s desarrollar?''';
    }
    
    if (lowerMessage.contains('alimentaci√≥n') || lowerMessage.contains('comida') || lowerMessage.contains('dieta')) {
      return '''La alimentaci√≥n es fundamental para la salud digestiva. Te comparto algunos consejos nutricionales:

‚Ä¢ Incluye fibra en tu dieta (frutas, verduras, cereales integrales)
‚Ä¢ Evita comidas muy condimentadas o grasosas
‚Ä¢ Mastica bien los alimentos
‚Ä¢ Bebe suficiente agua durante el d√≠a
‚Ä¢ Evita comer muy tarde en la noche

¬øTe gustar√≠a que te ayude a planificar comidas m√°s saludables?''';
    }
    
    // Respuesta general de fallback
    return '''Disculpa, el asistente de IA est√° temporalmente no disponible, pero estoy aqu√≠ para ayudarte.

Puedo asistirte con:
‚Ä¢ Crear h√°bitos saludables personalizados
‚Ä¢ Consejos sobre alimentaci√≥n y digesti√≥n
‚Ä¢ Rutinas de ejercicio y bienestar
‚Ä¢ T√©cnicas de manejo del estr√©s

¬øEn qu√© √°rea espec√≠fica te gustar√≠a que te ayude hoy?

Nota: El servicio completo de IA se restablecer√° pronto. Mientras tanto, puedo ofrecerte consejos basados en las mejores pr√°cticas de salud.''';
  }

  Future<String> _speechToText(String audioPath) async {
    // Placeholder para integraci√≥n con Speech-to-Text
    // Esto requerir√≠a integraci√≥n con Google Speech-to-Text API o similar
    throw UnimplementedError('Speech-to-Text no implementado a√∫n');
  }

  /// Genera un t√≠tulo descriptivo para una conversaci√≥n basado en el primer mensaje
  Future<String> generateConversationTitle(String firstMessage) async {
    try {
      final prompt = '''
Genera un t√≠tulo corto y descriptivo (m√°ximo 50 caracteres) para una conversaci√≥n de chat basado en este primer mensaje del usuario:

"$firstMessage"

El t√≠tulo debe:
- Ser conciso y claro
- Reflejar el tema principal del mensaje
- Estar en espa√±ol
- No incluir comillas ni caracteres especiales
- Ser apropiado para mostrar en una lista de conversaciones

Responde SOLO con el t√≠tulo, sin explicaciones adicionales.
''';

      final requestBody = {
        'contents': [{
          'parts': [{
            'text': prompt
          }]
        }],
        'generationConfig': {
          'temperature': 0.3,
          'topK': 20,
          'topP': 0.8,
          'maxOutputTokens': 100,
        },
        'safetySettings': [
          {
            'category': 'HARM_CATEGORY_HARASSMENT',
            'threshold': 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            'category': 'HARM_CATEGORY_HATE_SPEECH',
            'threshold': 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
            'threshold': 'BLOCK_MEDIUM_AND_ABOVE'
          },
          {
            'category': 'HARM_CATEGORY_DANGEROUS_CONTENT',
            'threshold': 'BLOCK_MEDIUM_AND_ABOVE'
          }
        ]
      };

      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/models/gemini-2.5-flash:generateContent?key=$_apiKey'),
        headers: {
          'Content-Type': 'application/json',
        },
        body: jsonEncode(requestBody),
      ).timeout(const Duration(seconds: 15));

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        final title = responseData['candidates']?[0]?['content']?['parts']?[0]?['text']?.trim() ?? 'Nueva conversaci√≥n';
        
        // Limpiar el t√≠tulo y asegurar que no exceda 50 caracteres
        String cleanTitle = title.replaceAll(RegExp(r'["\n\r]'), '').trim();
        if (cleanTitle.length > 50) {
          cleanTitle = cleanTitle.substring(0, 47) + '...';
        }
        
        return cleanTitle.isEmpty ? 'Nueva conversaci√≥n' : cleanTitle;
      } else {
        print('‚ùå Error al generar t√≠tulo: ${response.statusCode}');
        return _generateFallbackTitle(firstMessage);
      }
    } catch (e) {
      print('‚ùå Error al generar t√≠tulo con Gemini: $e');
      return _generateFallbackTitle(firstMessage);
    }
  }

  /// Genera un t√≠tulo de fallback basado en palabras clave del mensaje
  String _generateFallbackTitle(String message) {
    final lowerMessage = message.toLowerCase();
    
    // T√≠tulos basados en palabras clave comunes
    if (lowerMessage.contains('dolor') || lowerMessage.contains('duele')) {
      return 'Consulta sobre dolor';
    } else if (lowerMessage.contains('h√°bito') || lowerMessage.contains('rutina')) {
      return 'Creaci√≥n de h√°bitos';
    } else if (lowerMessage.contains('s√≠ntoma') || lowerMessage.contains('s√≠ntomas')) {
      return 'Registro de s√≠ntomas';
    } else if (lowerMessage.contains('gastritis') || lowerMessage.contains('est√≥mago')) {
      return 'Consulta digestiva';
    } else if (lowerMessage.contains('ejercicio') || lowerMessage.contains('actividad')) {
      return 'Actividad f√≠sica';
    } else if (lowerMessage.contains('alimentaci√≥n') || lowerMessage.contains('comida')) {
      return 'Consulta nutricional';
    } else if (lowerMessage.contains('progreso') || lowerMessage.contains('avance')) {
      return 'Seguimiento de progreso';
    } else {
      // Usar las primeras palabras del mensaje
      final words = message.split(' ').take(4).join(' ');
      return words.length > 50 ? words.substring(0, 47) + '...' : words;
    }
  }

  /// Obtiene respuesta inicial r√°pida de Gemini optimizada para velocidad
  Future<String> _getInitialGeminiResponse(
    String message,
    String userId,
    List<ChatMessage> conversationHistory,
  ) async {
    final prompt = await _buildInitialPrompt(
      message: message,
      userId: userId,
      conversationHistory: conversationHistory,
    );
    
    final requestBody = {
      'contents': [{
        'parts': [{
          'text': prompt
        }]
      }],
      'generationConfig': {
        'temperature': 0.6, // Menos creatividad para respuesta m√°s r√°pida
        'topK': 20,
        'topP': 0.8,
        'maxOutputTokens': 1024, // Respuesta m√°s corta para velocidad
      },
    };

    try {
      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/models/gemini-2.5-flash:generateContent?key=$_apiKey'),
        headers: {
          'Content-Type': 'application/json',
        },
        body: jsonEncode(requestBody),
      ).timeout(const Duration(seconds: 30)); // Timeout m√°s corto

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        final geminiText = responseData['candidates']?[0]?['content']?['parts']?[0]?['text'] ?? 
                          'Estoy analizando tu mensaje, por favor espera un momento...';
        
        print('‚úÖ [INITIAL] Respuesta inicial de Gemini obtenida: ${geminiText.length} caracteres');
        return geminiText;
      } else {
        throw Exception('Error HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('‚ùå [INITIAL] Error en respuesta inicial de Gemini: $e');
      rethrow;
    }
  }

  /// Construye prompt inicial optimizado para respuesta r√°pida
  Future<String> _buildInitialPrompt({
    required String message,
    String? userId,
    List<ChatMessage>? conversationHistory,
  }) async {
    final buffer = StringBuffer();
    
    buffer.writeln('Eres "Vive Good", asistente especializado en prevenci√≥n de gastritis.');
    buffer.writeln('Proporciona una respuesta inicial breve y emp√°tica (m√°ximo 100 palabras).');
    buffer.writeln('Enf√≥cate en reconocer el mensaje del usuario y ofrecer apoyo inmediato.');
    buffer.writeln('');
    buffer.writeln('Mensaje del usuario: "$message"');
    buffer.writeln('');
    buffer.writeln('Responde de forma c√°lida y profesional, indicando que est√°s analizando su situaci√≥n.');
    
    return buffer.toString();
  }

  /// Extrae s√≠ntomas del mensaje del usuario para el an√°lisis m√©dico
  Map<String, dynamic> _extractSymptomsFromMessage(String message) {
    final symptoms = <String>[];
    final messageLower = message.toLowerCase();
    
    // S√≠ntomas comunes de gastritis
    final symptomKeywords = {
      'dolor abdominal': ['dolor', 'duele', 'molestia', 'ardor', 'est√≥mago'],
      'acidez': ['acidez', 'reflujo', 'agruras', '√°cido'],
      'nauseas': ['nauseas', 'n√°useas', 'ganas de vomitar', 'mareo'],
      'inflamacion': ['inflamaci√≥n', 'hinchaz√≥n', 'distensi√≥n', 'pesadez'],
      'perdida_apetito': ['sin apetito', 'no tengo hambre', 'p√©rdida de apetito'],
    };
    
    for (final entry in symptomKeywords.entries) {
      for (final keyword in entry.value) {
        if (messageLower.contains(keyword)) {
          symptoms.add(entry.key);
          break;
        }
      }
    }
    
    return {
      'detected_symptoms': symptoms,
      'severity_estimation': symptoms.length > 2 ? 'moderado' : 'leve',
      'message_analysis': {
        'contains_symptoms': symptoms.isNotEmpty,
        'symptom_count': symptoms.length,
        'original_message': message,
      }
    };
  }

  /// Obtiene an√°lisis m√©dico del nuevo endpoint
  Future<MedicalAnalysisResponse?> _getMedicalAnalysis({
    required String userId,
    required String userMessage,
    required Map<String, dynamic> extractedSymptoms,
    required Function(String) onProgress,
  }) async {
    if (_deepLearningDatasource == null) {
      print('‚ö†Ô∏è [MEDICAL] Deep Learning datasource no configurado');
      return null;
    }
    
    try {
      onProgress('Conectando con an√°lisis m√©dico...');
      
      // Verificar salud del servicio
      final isHealthy = await _deepLearningDatasource!.checkModelHealth();
      if (!isHealthy) {
        print('‚ö†Ô∏è [MEDICAL] Servicio de an√°lisis m√©dico no disponible');
        return null;
      }
      
      onProgress('Analizando s√≠ntomas detectados...');
      
      // Llamar al nuevo endpoint de an√°lisis m√©dico
      final medicalAnalysis = await _deepLearningDatasource!.analyzeMedicalSymptoms(
        userId: userId,
        userMessage: userMessage,
        extractedSymptoms: extractedSymptoms,
        userContext: {
          'timestamp': DateTime.now().toIso8601String(),
          'source': 'progressive_response',
        },
      );
      
      print('‚úÖ [MEDICAL] An√°lisis m√©dico completado exitosamente');
      return medicalAnalysis;
      
    } catch (e) {
      print('‚ùå [MEDICAL] Error en an√°lisis m√©dico: $e');
      return null;
    }
  }

  /// Combina la respuesta inicial de Gemini con el an√°lisis m√©dico
  Future<AssistantResponseModel> _combineGeminiWithMedicalAnalysis({
    required AssistantResponseModel initialResponse,
    required MedicalAnalysisResponse medicalAnalysis,
    required String originalMessage,
    required String userId,
    required Function(String) onProgress,
  }) async {
    try {
      onProgress('Generando respuesta final integrada...');
      
      // Construir prompt mejorado con an√°lisis m√©dico
      final enhancedPrompt = await _buildEnhancedPromptWithMedicalAnalysis(
        originalMessage: originalMessage,
        initialResponse: initialResponse.content,
        medicalAnalysis: medicalAnalysis,
        userId: userId,
      );
      
      onProgress('Refinando recomendaciones...');
      
      // Obtener respuesta final mejorada de Gemini
      final enhancedGeminiResponse = await _getEnhancedGeminiResponse(enhancedPrompt);
      
      // Procesar respuesta final
      String finalMessage = enhancedGeminiResponse;
      Map<String, dynamic> finalActions = initialResponse.processedActions ?? {};
      
      if (_responseProcessor != null) {
        try {
          final processedResponse = await _responseProcessor!.processGeminiResponse(
            enhancedGeminiResponse,
            userId,
          );
          
          processedResponse.fold(
            (failure) {
              print('‚ùå [COMBINE] Error procesando respuesta final: $failure');
            },
            (processed) {
              finalMessage = processed.message;
              finalActions = processed.actions;
            },
          );
        } catch (e) {
          print('‚ùå [COMBINE] Error en procesamiento final: $e');
        }
      }
      
      // Extraer h√°bitos mejorados basados en an√°lisis m√©dico
      final enhancedHabits = await _extractHabitsFromMedicalAnalysis(medicalAnalysis, userId);
      
      onProgress('Completando an√°lisis...');
      
      // Crear respuesta final combinada
      return AssistantResponseModel(
        id: initialResponse.id,
        sessionId: initialResponse.sessionId,
        content: finalMessage,
        type: ResponseType.text,
        timestamp: DateTime.now(),
        confidence: _calculateCombinedConfidence(initialResponse.confidence, medicalAnalysis.confidence),
        suggestions: _generateSuggestionsFromMedicalAnalysis(medicalAnalysis),
        extractedHabits: enhancedHabits,
        analysisData: _convertMedicalAnalysisToLegacyFormat(medicalAnalysis),
        suggestedHabits: enhancedHabits.map((h) => h.toMap()).toList(),
        dlChatResponse: _createDLChatResponseFromMedicalAnalysis(medicalAnalysis),
        processedActions: finalActions,
      );
      
    } catch (e) {
      print('‚ùå [COMBINE] Error combinando respuestas: $e');
      // Retornar respuesta inicial en caso de error
      return initialResponse;
    }
  }

  /// Construye prompt mejorado con an√°lisis m√©dico
  Future<String> _buildEnhancedPromptWithMedicalAnalysis({
    required String originalMessage,
    required String initialResponse,
    required MedicalAnalysisResponse medicalAnalysis,
    required String userId,
  }) async {
    final buffer = StringBuffer();
    
    buffer.writeln('Eres "Vive Good", asistente especializado en prevenci√≥n de gastritis.');
    buffer.writeln('Tienes acceso a un an√°lisis m√©dico especializado que debes integrar en tu respuesta.');
    buffer.writeln('');
    buffer.writeln('MENSAJE ORIGINAL DEL USUARIO:');
    buffer.writeln('"$originalMessage"');
    buffer.writeln('');
    buffer.writeln('TU RESPUESTA INICIAL:');
    buffer.writeln('"$initialResponse"');
    buffer.writeln('');
    buffer.writeln('AN√ÅLISIS M√âDICO ESPECIALIZADO:');
    buffer.writeln('‚Ä¢ S√≠ntomas detectados: ${medicalAnalysis.symptomAnalysis.detectedSymptoms.join(", ")}');
    buffer.writeln('‚Ä¢ Nivel de severidad: ${medicalAnalysis.symptomAnalysis.severityLevel}');
    buffer.writeln('‚Ä¢ Urgencia: ${medicalAnalysis.symptomAnalysis.urgency}');
    buffer.writeln('‚Ä¢ Nivel de riesgo: ${medicalAnalysis.riskAssessment.riskLevel}');
    buffer.writeln('‚Ä¢ Confianza del an√°lisis: ${(medicalAnalysis.confidence * 100).toStringAsFixed(1)}%');
    buffer.writeln('');
    buffer.writeln('RECOMENDACIONES M√âDICAS:');
    buffer.writeln('Diet√©ticas:');
    for (final rec in medicalAnalysis.recommendations.dietary) {
      buffer.writeln('‚Ä¢ $rec');
    }
    buffer.writeln('Estilo de vida:');
    for (final rec in medicalAnalysis.recommendations.lifestyle) {
      buffer.writeln('‚Ä¢ $rec');
    }
    if (medicalAnalysis.recommendations.medical.isNotEmpty) {
      buffer.writeln('M√©dicas:');
      for (final rec in medicalAnalysis.recommendations.medical) {
        buffer.writeln('‚Ä¢ $rec');
      }
    }
    buffer.writeln('');
    buffer.writeln('SEGUIMIENTO: ${medicalAnalysis.riskAssessment.followUp}');
    buffer.writeln('');
    buffer.writeln('INSTRUCCIONES:');
    buffer.writeln('1. Combina tu respuesta inicial con el an√°lisis m√©dico especializado');
    buffer.writeln('2. Proporciona una respuesta completa y coherente (m√°ximo 300 palabras)');
    buffer.writeln('3. Incluye las recomendaciones m√©dicas de forma natural');
    buffer.writeln('4. Mant√©n un tono emp√°tico y profesional');
    buffer.writeln('5. Sugiere h√°bitos espec√≠ficos basados en el an√°lisis');
    buffer.writeln('6. Si hay urgencia m√©dica, enfat√≠zalo apropiadamente');
    
    return buffer.toString();
  }

  /// Obtiene respuesta mejorada de Gemini con an√°lisis m√©dico
  Future<String> _getEnhancedGeminiResponse(String enhancedPrompt) async {
    final requestBody = {
      'contents': [{
        'parts': [{
          'text': enhancedPrompt
        }]
      }],
      'generationConfig': {
        'temperature': 0.7,
        'topK': 40,
        'topP': 0.95,
        'maxOutputTokens': 2048,
      },
    };

    try {
      final response = await _httpClient.post(
        Uri.parse('$_baseUrl/models/gemini-2.5-flash:generateContent?key=$_apiKey'),
        headers: {
          'Content-Type': 'application/json',
        },
        body: jsonEncode(requestBody),
      ).timeout(const Duration(seconds: 60));

      if (response.statusCode == 200) {
        final responseData = jsonDecode(response.body);
        final geminiText = responseData['candidates']?[0]?['content']?['parts']?[0]?['text'] ?? 
                          'Lo siento, no pude procesar la informaci√≥n m√©dica.';
        
        print('‚úÖ [ENHANCED] Respuesta mejorada de Gemini obtenida: ${geminiText.length} caracteres');
        return geminiText;
      } else {
        throw Exception('Error HTTP ${response.statusCode}: ${response.body}');
      }
    } catch (e) {
      print('‚ùå [ENHANCED] Error en respuesta mejorada de Gemini: $e');
      rethrow;
    }
  }

  /// Extrae h√°bitos basados en an√°lisis m√©dico
  Future<List<dynamic>> _extractHabitsFromMedicalAnalysis(MedicalAnalysisResponse medicalAnalysis, String userId) async {
    final habits = <Map<String, dynamic>>[];
    
    // Convertir recomendaciones diet√©ticas en h√°bitos
    for (final dietary in medicalAnalysis.recommendations.dietary) {
      habits.add({
        'name': 'H√°bito diet√©tico: ${dietary.substring(0, dietary.length > 30 ? 30 : dietary.length)}...',
        'description': dietary,
        'category': 'alimentacion',
        'frequency': 'daily',
        'source': 'medical_analysis',
      });
    }
    
    // Convertir recomendaciones de estilo de vida en h√°bitos
    for (final lifestyle in medicalAnalysis.recommendations.lifestyle) {
      habits.add({
        'name': 'H√°bito de estilo de vida: ${lifestyle.substring(0, lifestyle.length > 30 ? 30 : lifestyle.length)}...',
        'description': lifestyle,
        'category': 'estilo_vida',
        'frequency': 'daily',
        'source': 'medical_analysis',
      });
    }
    
    return habits;
  }

  /// Calcula confianza combinada
  double _calculateCombinedConfidence(double geminiConfidence, double medicalConfidence) {
    // Promedio ponderado: 60% Gemini, 40% an√°lisis m√©dico
    return (geminiConfidence * 0.6) + (medicalConfidence * 0.4);
  }

  /// Genera sugerencias basadas en an√°lisis m√©dico
  List<String> _generateSuggestionsFromMedicalAnalysis(MedicalAnalysisResponse medicalAnalysis) {
    final suggestions = <String>[];
    
    // Agregar sugerencias basadas en nivel de riesgo
    switch (medicalAnalysis.riskAssessment.riskLevel.toLowerCase()) {
      case 'alto':
        suggestions.add('Consulta con un m√©dico pronto');
        suggestions.add('Evita alimentos irritantes');
        break;
      case 'moderado':
        suggestions.add('Modifica tu dieta gradualmente');
        suggestions.add('Monitorea tus s√≠ntomas');
        break;
      case 'bajo':
        suggestions.add('Mant√©n h√°bitos preventivos');
        suggestions.add('Contin√∫a con alimentaci√≥n saludable');
        break;
    }
    
    // Agregar sugerencias espec√≠ficas de las recomendaciones
    if (medicalAnalysis.recommendations.dietary.isNotEmpty) {
      suggestions.add(medicalAnalysis.recommendations.dietary.first);
    }
    if (medicalAnalysis.recommendations.lifestyle.isNotEmpty) {
      suggestions.add(medicalAnalysis.recommendations.lifestyle.first);
    }
    
    return suggestions.take(4).toList();
  }

  /// Convierte an√°lisis m√©dico a formato legacy
  Map<String, dynamic>? _convertMedicalAnalysisToLegacyFormat(MedicalAnalysisResponse medicalAnalysis) {
    return {
      'analysis_id': medicalAnalysis.analysisId,
      'confidence': medicalAnalysis.confidence,
      'risk_level': medicalAnalysis.riskAssessment.riskLevel,
      'symptoms': medicalAnalysis.symptomAnalysis.detectedSymptoms,
      'recommendations': [
        ...medicalAnalysis.recommendations.dietary,
        ...medicalAnalysis.recommendations.lifestyle,
        ...medicalAnalysis.recommendations.medical,
      ],
      'follow_up': medicalAnalysis.riskAssessment.followUp,
      'timestamp': medicalAnalysis.timestamp.toIso8601String(),
    };
  }

  /// Crea respuesta DL compatible con formato legacy
  Map<String, dynamic> _createDLChatResponseFromMedicalAnalysis(MedicalAnalysisResponse medicalAnalysis) {
    return {
      'response': 'An√°lisis m√©dico completado con ${medicalAnalysis.symptomAnalysis.detectedSymptoms.length} s√≠ntomas detectados.',
      'confidence': medicalAnalysis.confidence,
      'analysis_data': _convertMedicalAnalysisToLegacyFormat(medicalAnalysis),
      'recommendations': [
        ...medicalAnalysis.recommendations.dietary,
        ...medicalAnalysis.recommendations.lifestyle,
      ],
      'risk_assessment': {
        'level': medicalAnalysis.riskAssessment.riskLevel,
        'urgency': medicalAnalysis.symptomAnalysis.urgency,
      },
    };
  }

  void dispose() {
    _httpClient.close();
  }
}